// Init libs
var ROSLIB = require('roslib');
// Setup exports
module.exports = {
/*
 * This message converter should be autogenerated from
 * ROS message definition language.
 * TODO: converter implementation.
 */
    abi: [{"constant":true,"inputs":[],"name":"data","outputs":[{"name":"","type":"int64"}],"type":"function"},{"inputs":[{"name":"_data","type":"int64"}],"type":"constructor"}], 
    eth2ros: function(msg) {return new ROSLIB.Message({data: parseInt(msg.data())})},
    ros2eth: function(msg, web3, fun) {
    var bytecode = '60606040526040516020806085833950608060405251600080547801000000000000000000000000000000000000000000000000808402046001604060020a03199091161790555060328060536000396000f3606060405260e060020a600035046373d4a13a8114601a575b005b602560005460070b81565b60070b6060908152602090f3';
    var abi = [{"constant":true,"inputs":[],"name":"data","outputs":[{"name":"","type":"int64"}],"type":"function"},{"inputs":[{"name":"_data","type":"int64"}],"type":"constructor"}]; 
    web3.eth.contract(abi).new(msg.data, 
        { from: web3.eth.accounts[0],
          data: bytecode,
          gas: 3000000
        }, function(e, contract) {
            if (typeof contract.address != 'undefined')
                fun(null, contract.address);
        });
}
}
